#!/usr/bin/env python3
"""
Device Onboarding API Service

Primary Key: Device ID (auto-generated by NetBox)
- Manual Onboarding: IP address required
- DHCP Onboarding (future): MAC address required

Usage:
    python onboarding_api.py

Endpoints:
    POST /api/onboard      - Manual onboarding with IP
    POST /api/onboard/dhcp - DHCP onboarding with MAC (future)
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
import requests
from requests.adapters import HTTPAdapter
import re
import os
from datetime import datetime
from cryptography.fernet import Fernet

app = Flask(__name__)
CORS(app)

# Configuration
NETBOX_URL = os.environ.get('NETBOX_URL', 'http://localhost:8000')
NETBOX_TOKEN = os.environ.get('NETBOX_TOKEN', '0123456789abcdef0123456789abcdef01234567')
ENCRYPTION_KEY = os.environ.get('NETBOX_DEVICE_ENCRYPTION_KEY', 'XPmjtY0wwxQbD0ezEMDhGlAo2_JGXb6yB4yp5I-MnGA=')

HEADERS = {
    'Authorization': f'Token {NETBOX_TOKEN}',
    'Content-Type': 'application/json'
}

# Create a session with connection pooling
session = requests.Session()
session.headers.update(HEADERS)
adapter = HTTPAdapter(pool_connections=10, pool_maxsize=10)
session.mount('http://', adapter)
session.mount('https://', adapter)

# Regex patterns
MAC_PATTERN = re.compile(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$|^([0-9A-Fa-f]{4}\.){2}([0-9A-Fa-f]{4})$')

# Use Python's ipaddress module for reliable IP validation
import ipaddress


def detect_ip_version(ip):
    """Detect if IP is IPv4 or IPv6 using Python's ipaddress module"""
    try:
        addr = ipaddress.ip_address(ip)
        if isinstance(addr, ipaddress.IPv4Address):
            return 'ipv4'
        elif isinstance(addr, ipaddress.IPv6Address):
            return 'ipv6'
    except ValueError:
        pass
    return None


def is_valid_mac(mac):
    """Validate MAC address format"""
    return bool(MAC_PATTERN.match(mac))


def normalize_mac(mac):
    """Normalize MAC address to AA:BB:CC:DD:EE:FF format"""
    mac_clean = re.sub(r'[.:-]', '', mac).upper()
    return ':'.join(mac_clean[i:i+2] for i in range(0, 12, 2))


def encrypt_password(password):
    """Encrypt password using Fernet"""
    try:
        key = ENCRYPTION_KEY
        if isinstance(key, str):
            key = key.encode()
        cipher = Fernet(key)
        return cipher.encrypt(password.encode()).decode()
    except Exception:
        return password


def check_ip_exists(ip_address):
    """Check if IP address already exists in NetBox"""
    try:
        response = session.get(
            f"{NETBOX_URL}/api/ipam/ip-addresses/",
            params={'address': ip_address}
        )
        if response.status_code == 200:
            data = response.json()
            if data['count'] > 0:
                result = data['results'][0]
                device_name = None
                device_id = None
                if result.get('assigned_object') and result['assigned_object'].get('device'):
                    device_name = result['assigned_object']['device'].get('name')
                    device_id = result['assigned_object']['device'].get('id')
                return {
                    'exists': True,
                    'ip_id': result['id'],
                    'address': result['address'],
                    'device_name': device_name,
                    'device_id': device_id
                }
        return {'exists': False}
    except Exception as e:
        return {'exists': False, 'error': str(e)}


def check_ip_device_reachable(ip_address):
    """
    Check if IP exists and if the device is reachable.
    Used for DHCP to allow IP reassignment only if device is down.
    """
    try:
        # First check if IP exists
        ip_check = check_ip_exists(ip_address)
        if not ip_check['exists']:
            return {'exists': False, 'can_reassign': True}

        device_id = ip_check.get('device_id')
        if not device_id:
            # IP exists but not assigned to device - can reassign
            return {
                'exists': True,
                'can_reassign': True,
                'ip_id': ip_check.get('ip_id'),
                'reason': 'IP not assigned to any device'
            }

        # Get device details including reachable status
        response = session.get(f"{NETBOX_URL}/api/dcim/devices/{device_id}/")
        if response.status_code == 200:
            device = response.json()
            custom_fields = device.get('custom_fields', {})
            reachable = custom_fields.get('reachable', None)

            # If reachable is True (device is up), don't allow reassignment
            if reachable is True:
                return {
                    'exists': True,
                    'can_reassign': False,
                    'device_id': device_id,
                    'device_name': device.get('name'),
                    'device_reachable': True,
                    'ip_id': ip_check.get('ip_id'),
                    'reason': 'Device is reachable (up)'
                }
            else:
                # Device is down or reachable status unknown - allow reassignment
                return {
                    'exists': True,
                    'can_reassign': True,
                    'device_id': device_id,
                    'device_name': device.get('name'),
                    'device_reachable': reachable,
                    'ip_id': ip_check.get('ip_id'),
                    'reason': 'Device is down or status unknown'
                }

        return {'exists': True, 'can_reassign': True, 'reason': 'Could not get device status'}
    except Exception as e:
        return {'exists': False, 'can_reassign': True, 'error': str(e)}


def check_device_exists(device_name):
    """Check if device name already exists in NetBox"""
    try:
        response = session.get(
            f"{NETBOX_URL}/api/dcim/devices/",
            params={'name': device_name}
        )
        if response.status_code == 200:
            data = response.json()
            if data['count'] > 0:
                result = data['results'][0]
                return {
                    'exists': True,
                    'device_id': result['id'],
                    'device_name': result['name'],
                    'primary_ip': result.get('primary_ip4', {}).get('address') if result.get('primary_ip4') else None
                }
        return {'exists': False}
    except Exception as e:
        return {'exists': False, 'error': str(e)}


def check_mac_exists(mac_address):
    """Check if MAC address already exists in NetBox interfaces"""
    try:
        normalized_mac = normalize_mac(mac_address)
        response = session.get(
            f"{NETBOX_URL}/api/dcim/interfaces/",
            params={'mac_address': normalized_mac}
        )
        if response.status_code == 200:
            data = response.json()
            if data['count'] > 0:
                result = data['results'][0]
                return {
                    'exists': True,
                    'interface_id': result['id'],
                    'mac_address': result['mac_address'],
                    'device_id': result.get('device', {}).get('id'),
                    'device_name': result.get('device', {}).get('name')
                }
        return {'exists': False}
    except Exception as e:
        return {'exists': False, 'error': str(e)}


# =============================================================================
# MANUAL ONBOARDING (IP Required)
# =============================================================================
@app.route('/api/onboard', methods=['POST'])
def onboard_device():
    """
    Manual Device Onboarding - IP address required

    Primary Key: Device ID (auto-generated)
    Unique Identifier: IP address (validated for duplicates)

    Request Body:
    {
        "ip": "192.168.1.100",        # Required - IPv4 or IPv6
        "device_type": 1,             # Required
        "role": 1,                    # Required
        "site": 1,                    # Optional (default: 1)
        "username": "admin",          # Optional
        "password": "secret123"       # Optional (encrypted)
    }
    """
    try:
        data = request.get_json()

        # Extract fields
        ip_address = data.get('ip', '').strip() if data.get('ip') else None
        device_type_id = data.get('device_type')
        role_id = data.get('role')
        site_id = data.get('site', 1)
        username = data.get('username', '')
        password = data.get('password', '')

        # ================== VALIDATION ==================
        if not ip_address:
            return jsonify({
                'status': 'error',
                'error': 'ip is required for manual onboarding',
                'field': 'ip'
            }), 400

        ip_version = detect_ip_version(ip_address)
        if not ip_version:
            return jsonify({
                'status': 'error',
                'error': f'Invalid IP address format: {ip_address}',
                'field': 'ip',
                'hint': 'Must be valid IPv4 (192.168.1.100) or IPv6 (2001:db8::1)'
            }), 400

        if not device_type_id:
            return jsonify({
                'status': 'error',
                'error': 'device_type is required',
                'field': 'device_type'
            }), 400

        if not role_id:
            return jsonify({
                'status': 'error',
                'error': 'role is required',
                'field': 'role'
            }), 400

        # ================== CHECK DUPLICATES ==================
        # Check if device with this IP as name already exists
        device_check = check_device_exists(ip_address)
        if device_check['exists']:
            return jsonify({
                'status': 'error',
                'error': 'Device already exists with this IP',
                'field': 'ip',
                'ip_address': ip_address,
                'existing': {
                    'device_id': device_check.get('device_id'),
                    'device_name': device_check.get('device_name'),
                    'primary_ip': device_check.get('primary_ip')
                }
            }), 409

        # Check if IP address already exists
        ip_check = check_ip_exists(ip_address)
        if ip_check['exists']:
            return jsonify({
                'status': 'error',
                'error': 'IP address already exists',
                'field': 'ip',
                'ip_address': ip_address,
                'existing': {
                    'ip_id': ip_check.get('ip_id'),
                    'device_id': ip_check.get('device_id'),
                    'device_name': ip_check.get('device_name')
                }
            }), 409

        # ================== CREATE DEVICE ==================
        device_name = ip_address  # Use IP as display name
        encrypted_password = encrypt_password(password) if password else ''

        # Custom fields - use 'username' and 'password' field names
        custom_fields = {}
        if username:
            custom_fields['username'] = username
        if encrypted_password:
            custom_fields['password'] = encrypted_password

        device_payload = {
            'name': device_name,
            'device_type': device_type_id,
            'role': role_id,
            'site': site_id,
            'status': 'active',
            'custom_fields': custom_fields
        }

        device_response = session.post(
            f"{NETBOX_URL}/api/dcim/devices/",
            json=device_payload
        )

        if device_response.status_code not in [200, 201] and 'custom field' in device_response.text.lower():
            del device_payload['custom_fields']
            device_response = session.post(
                f"{NETBOX_URL}/api/dcim/devices/",
                json=device_payload
            )

        if device_response.status_code not in [200, 201]:
            return jsonify({
                'status': 'error',
                'error': 'Failed to create device',
                'details': device_response.text
            }), 500

        device_data = device_response.json()
        device_id = device_data['id']

        # ================== CREATE INTERFACE ==================
        interface_response = session.post(
            f"{NETBOX_URL}/api/dcim/interfaces/",
            json={
                'device': device_id,
                'name': 'mgmt0',
                'type': 'virtual'
            }
        )

        interface_id = None
        interface_error = None
        if interface_response.status_code in [200, 201]:
            interface_id = interface_response.json()['id']
        else:
            interface_error = interface_response.text

        # ================== CREATE IP ADDRESS ==================
        cidr = f"{ip_address}/32" if ip_version == 'ipv4' else f"{ip_address}/128"

        ip_payload = {
            'address': cidr,
            'status': 'active'
        }
        if interface_id:
            ip_payload['assigned_object_type'] = 'dcim.interface'
            ip_payload['assigned_object_id'] = interface_id

        ip_response = session.post(
            f"{NETBOX_URL}/api/ipam/ip-addresses/",
            json=ip_payload
        )

        ip_id = None
        ip_create_error = None
        if ip_response.status_code in [200, 201]:
            ip_id = ip_response.json()['id']
        else:
            ip_create_error = ip_response.text

        # ================== SET PRIMARY IP ==================
        primary_ip_set = False
        primary_field = 'primary_ip4' if ip_version == 'ipv4' else 'primary_ip6'
        assign_error = None

        if ip_id:
            assign_response = session.patch(
                f"{NETBOX_URL}/api/dcim/devices/{device_id}/",
                json={primary_field: ip_id}
            )
            primary_ip_set = assign_response.status_code == 200
            if not primary_ip_set:
                assign_error = assign_response.text

        # ================== SUCCESS ==================
        return jsonify({
            'status': 'success',
            'message': 'Device onboarded successfully',
            'data': {
                'device_id': device_id,          # PRIMARY KEY
                'device_name': device_name,
                'ip_address': ip_address,
                'ip_version': ip_version,
                'ip_id': ip_id,
                'ip_cidr': f"{ip_address}/32" if ip_version == 'ipv4' else f"{ip_address}/128",
                'primary_field': primary_field,
                'interface_id': interface_id,
                'device_type': device_type_id,
                'role': role_id,
                'site': site_id,
                'primary_ip_assigned': primary_ip_set,
                'interface_error': interface_error,
                'ip_create_error': ip_create_error,
                'assign_error': assign_error,
                'onboard_type': 'manual'
            }
        }), 201

    except Exception as e:
        return jsonify({
            'status': 'error',
            'error': str(e)
        }), 500


# =============================================================================
# DHCP ONBOARDING (MAC Required) - Future Implementation
# =============================================================================
@app.route('/api/onboard/dhcp', methods=['POST'])
def onboard_device_dhcp():
    """
    DHCP Device Onboarding - MAC address required

    Primary Key: Device ID (auto-generated)
    Unique Identifier: MAC address (validated for duplicates)

    Request Body:
    {
        "mac": "AA:BB:CC:DD:EE:FF",    # Required - MAC address
        "ip": "192.168.1.100",          # Optional - assigned by DHCP
        "device_type": 1,               # Required
        "role": 1,                      # Required
        "site": 1,                      # Optional (default: 1)
        "hostname": "device-001"        # Optional - DHCP hostname
    }
    """
    try:
        data = request.get_json()

        # Extract fields
        mac_address = data.get('mac', '').strip() if data.get('mac') else None
        ip_address = data.get('ip', '').strip() if data.get('ip') else None
        device_type_id = data.get('device_type')
        role_id = data.get('role')
        site_id = data.get('site', 1)
        hostname = data.get('hostname', '').strip() if data.get('hostname') else None

        # ================== VALIDATION ==================
        if not mac_address:
            return jsonify({
                'status': 'error',
                'error': 'mac is required for DHCP onboarding',
                'field': 'mac'
            }), 400

        if not is_valid_mac(mac_address):
            return jsonify({
                'status': 'error',
                'error': f'Invalid MAC address format: {mac_address}',
                'field': 'mac',
                'hint': 'Must be valid MAC (AA:BB:CC:DD:EE:FF or AA-BB-CC-DD-EE-FF)'
            }), 400

        mac_address = normalize_mac(mac_address)

        if not device_type_id:
            return jsonify({
                'status': 'error',
                'error': 'device_type is required',
                'field': 'device_type'
            }), 400

        if not role_id:
            return jsonify({
                'status': 'error',
                'error': 'role is required',
                'field': 'role'
            }), 400

        # Validate IP if provided
        ip_version = None
        if ip_address:
            ip_version = detect_ip_version(ip_address)
            if not ip_version:
                return jsonify({
                    'status': 'error',
                    'error': f'Invalid IP address format: {ip_address}',
                    'field': 'ip'
                }), 400

        # ================== CHECK DUPLICATE MAC (device name = MAC) ==================
        # Check if device with name=MAC already exists
        device_check = check_device_exists(mac_address)
        if device_check['exists']:
            return jsonify({
                'status': 'error',
                'error': 'Device already exists with this MAC',
                'field': 'mac',
                'mac_address': mac_address,
                'existing': {
                    'device_id': device_check.get('device_id'),
                    'device_name': device_check.get('device_name'),
                    'primary_ip': device_check.get('primary_ip')
                }
            }), 409

        # ================== CHECK IP - ALLOW ONLY IF DEVICE IS DOWN ==================
        # For DHCP: Same IP can be reassigned to different MAC ONLY if device is down
        existing_ip_id = None  # Track if we're reassigning an existing IP
        if ip_address:
            ip_device_check = check_ip_device_reachable(ip_address)
            if ip_device_check['exists']:
                if not ip_device_check['can_reassign']:
                    return jsonify({
                        'status': 'error',
                        'error': 'IP is assigned to an active device',
                        'field': 'ip',
                        'ip_address': ip_address,
                        'existing': {
                            'device_id': ip_device_check.get('device_id'),
                            'device_name': ip_device_check.get('device_name'),
                            'device_reachable': ip_device_check.get('device_reachable'),
                            'reason': ip_device_check.get('reason')
                        },
                        'hint': 'IP can only be reassigned if the device is down (reachable=false)'
                    }), 409
                else:
                    # IP exists and can be reassigned - save the IP ID for later reassignment
                    existing_ip_id = ip_device_check.get('ip_id')

        # ================== CREATE DEVICE ==================
        # Always use MAC as device name (unique identifier for DHCP devices)
        device_name = mac_address

        # Custom fields
        custom_fields = {}
        # hostname is just metadata, stored in custom field if provided
        if hostname:
            custom_fields['hostname'] = hostname

        device_payload = {
            'name': device_name,
            'device_type': device_type_id,
            'role': role_id,
            'site': site_id,
            'status': 'active',
            'custom_fields': custom_fields
        }

        device_response = session.post(
            f"{NETBOX_URL}/api/dcim/devices/",
            json=device_payload
        )

        if device_response.status_code not in [200, 201] and 'custom field' in device_response.text.lower():
            del device_payload['custom_fields']
            device_response = session.post(
                f"{NETBOX_URL}/api/dcim/devices/",
                json=device_payload
            )

        if device_response.status_code not in [200, 201]:
            return jsonify({
                'status': 'error',
                'error': 'Failed to create device',
                'details': device_response.text
            }), 500

        device_data = device_response.json()
        device_id = device_data['id']

        # ================== CREATE INTERFACE WITH MAC ==================
        # Use 'other' type which supports MAC addresses (virtual type doesn't)
        interface_response = session.post(
            f"{NETBOX_URL}/api/dcim/interfaces/",
            json={
                'device': device_id,
                'name': 'eth0',
                'type': 'other',
                'mac_address': mac_address
            }
        )

        interface_id = None
        interface_error = None
        interface_mac = None
        if interface_response.status_code in [200, 201]:
            interface_data = interface_response.json()
            interface_id = interface_data['id']
            interface_mac = interface_data.get('mac_address')
        else:
            interface_error = interface_response.text

        # ================== HANDLE IP ADDRESS (if provided) ==================
        ip_id = None
        ip_create_error = None
        ip_reassigned = False
        primary_ip_set = False
        assign_error = None

        if ip_address and interface_id:
            # Check if we're reassigning an existing IP or creating new
            if existing_ip_id:
                # REASSIGN: Update existing IP to point to new interface
                reassign_response = session.patch(
                    f"{NETBOX_URL}/api/ipam/ip-addresses/{existing_ip_id}/",
                    json={
                        'assigned_object_type': 'dcim.interface',
                        'assigned_object_id': interface_id,
                        'status': 'dhcp'
                    }
                )
                if reassign_response.status_code == 200:
                    ip_id = existing_ip_id
                    ip_reassigned = True
                else:
                    ip_create_error = f"Failed to reassign IP: {reassign_response.text}"
            else:
                # CREATE: New IP address
                cidr = f"{ip_address}/32" if ip_version == 'ipv4' else f"{ip_address}/128"
                ip_payload = {
                    'address': cidr,
                    'status': 'dhcp',
                    'assigned_object_type': 'dcim.interface',
                    'assigned_object_id': interface_id
                }

                ip_response = session.post(
                    f"{NETBOX_URL}/api/ipam/ip-addresses/",
                    json=ip_payload
                )

                if ip_response.status_code in [200, 201]:
                    ip_id = ip_response.json()['id']
                else:
                    ip_create_error = ip_response.text

            # Set as primary IP if we have an IP
            if ip_id:
                primary_field = 'primary_ip4' if ip_version == 'ipv4' else 'primary_ip6'
                assign_response = session.patch(
                    f"{NETBOX_URL}/api/dcim/devices/{device_id}/",
                    json={primary_field: ip_id}
                )
                primary_ip_set = assign_response.status_code == 200
                if not primary_ip_set:
                    assign_error = assign_response.text

        # ================== SUCCESS ==================
        return jsonify({
            'status': 'success',
            'message': 'Device onboarded via DHCP successfully',
            'data': {
                'device_id': device_id,          # PRIMARY KEY
                'device_name': device_name,
                'mac_address': mac_address,
                'interface_mac': interface_mac,
                'ip_address': ip_address,
                'ip_version': ip_version,
                'ip_id': ip_id,
                'ip_reassigned': ip_reassigned,
                'interface_id': interface_id,
                'device_type': device_type_id,
                'role': role_id,
                'site': site_id,
                'primary_ip_assigned': primary_ip_set,
                'interface_error': interface_error,
                'ip_create_error': ip_create_error,
                'assign_error': assign_error,
                'onboard_type': 'dhcp'
            }
        }), 201

    except Exception as e:
        return jsonify({
            'status': 'error',
            'error': str(e)
        }), 500


# =============================================================================
# VALIDATION ENDPOINTS
# =============================================================================
@app.route('/api/validate/ip', methods=['POST'])
def validate_ip():
    """Check if IP already exists"""
    try:
        data = request.get_json()
        ip_address = data.get('ip', '').strip() if data.get('ip') else None

        if not ip_address:
            return jsonify({'status': 'error', 'error': 'ip is required'}), 400

        ip_version = detect_ip_version(ip_address)
        if not ip_version:
            return jsonify({
                'status': 'error',
                'error': f'Invalid IP format: {ip_address}',
                'valid': False
            }), 400

        ip_check = check_ip_exists(ip_address)

        return jsonify({
            'status': 'exists' if ip_check['exists'] else 'available',
            'ip': ip_address,
            'ip_version': ip_version,
            'exists': ip_check['exists'],
            'can_create': not ip_check['exists'],
            'existing': ip_check if ip_check['exists'] else None
        }), 409 if ip_check['exists'] else 200

    except Exception as e:
        return jsonify({'status': 'error', 'error': str(e)}), 500


@app.route('/api/validate/mac', methods=['POST'])
def validate_mac():
    """Check if MAC already exists"""
    try:
        data = request.get_json()
        mac_address = data.get('mac', '').strip() if data.get('mac') else None

        if not mac_address:
            return jsonify({'status': 'error', 'error': 'mac is required'}), 400

        if not is_valid_mac(mac_address):
            return jsonify({
                'status': 'error',
                'error': f'Invalid MAC format: {mac_address}',
                'valid': False
            }), 400

        mac_address = normalize_mac(mac_address)
        mac_check = check_mac_exists(mac_address)

        return jsonify({
            'status': 'exists' if mac_check['exists'] else 'available',
            'mac': mac_address,
            'exists': mac_check['exists'],
            'can_create': not mac_check['exists'],
            'existing': mac_check if mac_check['exists'] else None
        }), 409 if mac_check['exists'] else 200

    except Exception as e:
        return jsonify({'status': 'error', 'error': str(e)}), 500


# =============================================================================
# HELPER ENDPOINTS
# =============================================================================
@app.route('/api/device-types', methods=['GET'])
def get_device_types():
    """Get list of available device types"""
    response = session.get(f"{NETBOX_URL}/api/dcim/device-types/")
    if response.status_code == 200:
        types = [{'id': dt['id'], 'name': dt['display']} for dt in response.json()['results']]
        return jsonify(types)
    return jsonify([]), response.status_code


@app.route('/api/device-roles', methods=['GET'])
def get_device_roles():
    """Get list of available device roles"""
    response = session.get(f"{NETBOX_URL}/api/dcim/device-roles/")
    if response.status_code == 200:
        roles = [{'id': r['id'], 'name': r['name']} for r in response.json()['results']]
        return jsonify(roles)
    return jsonify([]), response.status_code


@app.route('/api/sites', methods=['GET'])
def get_sites():
    """Get list of available sites"""
    response = session.get(f"{NETBOX_URL}/api/dcim/sites/")
    if response.status_code == 200:
        sites = [{'id': s['id'], 'name': s['name']} for s in response.json()['results']]
        return jsonify(sites)
    return jsonify([]), response.status_code


@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'netbox_url': NETBOX_URL,
        'primary_key': 'device_id (auto-generated)',
        'supported_modes': ['manual (IP)', 'dhcp (MAC)']
    })


@app.route('/', methods=['GET'])
def index():
    """API documentation"""
    return jsonify({
        'service': 'Device Onboarding API',
        'version': '2.0',
        'primary_key': 'device_id (auto-generated by NetBox)',
        'endpoints': {
            'POST /api/onboard': 'Manual onboarding (IP required)',
            'POST /api/onboard/dhcp': 'DHCP onboarding (MAC required)',
            'POST /api/validate/ip': 'Check if IP exists',
            'POST /api/validate/mac': 'Check if MAC exists',
            'GET /api/device-types': 'List device types',
            'GET /api/device-roles': 'List device roles',
            'GET /api/sites': 'List sites',
            'GET /health': 'Health check'
        },
        'manual_onboard': {
            'endpoint': 'POST /api/onboard',
            'payload': {
                'ip': '192.168.1.100 (Required - IPv4 or IPv6)',
                'device_type': '1 (Required)',
                'role': '1 (Required)',
                'site': '1 (Optional, default: 1)',
                'username': 'admin (Optional)',
                'password': 'secret123 (Optional, encrypted)'
            }
        },
        'dhcp_onboard': {
            'endpoint': 'POST /api/onboard/dhcp',
            'payload': {
                'mac': 'AA:BB:CC:DD:EE:FF (Required)',
                'ip': '192.168.1.100 (Optional - DHCP assigned)',
                'device_type': '1 (Required)',
                'role': '1 (Required)',
                'site': '1 (Optional)',
                'hostname': 'device-001 (Optional)'
            }
        }
    })


if __name__ == '__main__':
    print(f"""
================================================================================
Device Onboarding API Service v2.0
================================================================================
NetBox URL: {NETBOX_URL}
Primary Key: device_id (auto-generated by NetBox)

ENDPOINTS:
---------------------------------------------------------------------------
Manual Onboarding (IP required):
  POST /api/onboard
  Payload: {{"ip": "192.168.1.100", "device_type": 1, "role": 1}}

DHCP Onboarding (MAC required):
  POST /api/onboard/dhcp
  Payload: {{"mac": "AA:BB:CC:DD:EE:FF", "device_type": 1, "role": 1}}

Validation:
  POST /api/validate/ip   - Check if IP exists
  POST /api/validate/mac  - Check if MAC exists

Helpers:
  GET /api/device-types   - List device types
  GET /api/device-roles   - List device roles
  GET /api/sites          - List sites
  GET /health             - Health check
---------------------------------------------------------------------------

EXAMPLES:
  # Manual onboard with IP
  curl -X POST http://localhost:5001/api/onboard \\
    -H "Content-Type: application/json" \\
    -d '{{"ip": "192.168.1.100", "device_type": 1, "role": 1}}'

  # DHCP onboard with MAC
  curl -X POST http://localhost:5001/api/onboard/dhcp \\
    -H "Content-Type: application/json" \\
    -d '{{"mac": "AA:BB:CC:DD:EE:FF", "device_type": 1, "role": 1}}'

  # Validate IP before creating
  curl -X POST http://localhost:5001/api/validate/ip \\
    -H "Content-Type: application/json" \\
    -d '{{"ip": "192.168.1.100"}}'
================================================================================
""")
    app.run(host='0.0.0.0', port=5001, debug=True)
